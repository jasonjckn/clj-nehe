h1. Running the Tutorials

You need to have installed "Leiningen 1.1.0":http://github.com/technomancy/leiningen. Once you've done that you can run the following if you're using Emacs/SLIME or Enclojure:

<pre class="console">
lein deps
lein native-deps
lein swank
</pre>

You can then connect to this REPL. In Emacs/SLIME this can be done with *M-x slime-connect* and just press the enter key twice to use the defaults.

I highly recommend using Emacs/SLIME or Enclojure. It's useful when you're starting out to be able to jump to source definitions in Penumbra. In Emacs this can be done with *M-.* (that's *Meta-period*).

h1. Tricks

If you pass a display proxy function to your app you can interact with the tutorials without having to restart the application completely. No if you redefine *display* or any of the functions it calls your Penumbra app will update immediately. Interactive coding for the win!

<pre>
(defn display [[delta time] state]
  (clear)
  (gl-load-identity-matrix)
  (translate -1.5 0.0 -6.0)
  (draw-triangles
   (doall (map #(apply vertex %) *tri*)))
  (translate 3.0 0.0 0.0)
  (draw-quads
   (doall (map #(apply vertex %) *sqr*)))
  (app/repaint!))

(defn display-proxy [& args]
  (apply display args))

(def app-options {:reshape reshape
                  :display display-proxy
                  :init init})

(defn start []
  (app/start app-options {}))
</pre>

h1. Converting OpenGL API names

Penumbra chooses to approach OpenGL programming that is very different from the one most OpenGL binding libraries. Penumbra is an opinionated peice of software. This may be slightly disturbing at first because it's not immediately obvious how to translate OpenGL code you might find on the web to work under Penumbra.

h2. Naming Conventions

For the most part names have been shorted. You don't have to write the *gl* prefix before everything:

<pre>
glLoadIdentity()
</pre>

Becomes

<pre>
(load-identity)
</pre>

h2. glBegin()/glEnd()

Also you'll rarely see glBegin() or glEnd() in Penumbra code. You see something like *draw-[option]*:

<pre>
glBegin(GL_QUADS);
glVertex3f(1.0f, 1.0f, 1.0f);
glVertex3f(-1.0f, 1.0f, 1.0f);
glVertex3f(-1.0f, -1.0f, 1.0f);
glVertex3f(1.0f, -1.0f, 1.0f);
glEnd()
</pre>

Becomes

<pre>
(draw-quads
  (vertex 1 1 1)
  (vertex -1 1 1)
  (vertex -1 -1 1)
  (vertex 1 -1 1))
</pre>

In OpenGL you often specify many state options via OpenGL constants. In Penumbra you can do this with keywords, again dropping the *gl* prefix. Some examples:

<pre>
(enable :depth-test)
(depth-test :lequal)
(hint :perspective-correction-hint :nicest)
(shade-model :smooth)
</pre>

h1. Trouble Shooting

h2. Missing functions

Some of the OpenGL API exposed by Lightweight Java Game Library (LWJGL) has not been brought into Penumbra. However it's simple to import these things yourself with *gl-import*. For example *glClearDepth* has not been imported, but you just can import it yourself like so:

<pre>
(use '[penumbra.opengl.core :only [gl-import]])
(gl-import glClearDepth clear-depth)
</pre>

h2. Signatures

The signatures (or arglists) of your methods are *really* important. For example if you provide a reshape fn it must look something like the following:

<pre>
(defn reshape [[x y width height] state]
  ...)
</pre>

You can get a full list of required signatures here, "http://wiki.github.com/ztellman/penumbra/callbacks":http://wiki.github.com/ztellman/penumbra/callbacks.

It also important that if you use *app/start* with options you must also pass in a map for the state.

<pre>
(app/start callback-map {})
</pre>

If you don't your program will crash immediately.